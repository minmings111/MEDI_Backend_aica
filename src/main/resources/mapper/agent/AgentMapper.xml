<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.medi.backend.agent.mapper.AgentMapper">

    <select id="findVideoIdByYoutubeVideoId" resultType="java.lang.Integer">
        SELECT id 
        FROM youtube_videos
        WHERE youtube_video_id = #{youtubeVideoId} 
        LIMIT 1
    </select>

    <insert id="insertFilteredComment">
        INSERT INTO youtube_comments (
            video_id,
            youtube_comment_id,
            comment_text,
            commenter_name,
            published_at,
            like_count
        ) VALUES (
            #{videoId},
            #{youtubeCommentId},
            #{commentText},
            #{commenterName},
            STR_TO_DATE(#{publishedAt}, '%Y-%m-%dT%H:%i:%s.%fZ'),
            #{likeCount}
        )
        ON DUPLICATE KEY UPDATE
            comment_text = VALUES(comment_text),
            commenter_name = VALUES(commenter_name),
            published_at = VALUES(published_at),
            like_count = VALUES(like_count)
    </insert>

    <select id="findCommentIdByYoutubeCommentId" resultType="java.lang.Integer">
        SELECT id 
        FROM youtube_comments
        WHERE youtube_comment_id = #{youtubeCommentId}
        LIMIT 1
    </select>

    <insert id="insertCommentAnalysisResult">
        INSERT INTO ai_comment_analysis_result (
            youtube_comment_id,
            status,
            reason,
            analyzed_at,
            harmfulness_level,
            detection_source
        ) VALUES (
            #{youtubeCommentId},
            #{status},
            <choose>
                <when test="reason != null and reason != ''">
                    #{reason}
                </when>
                <otherwise>
                    NULL
                </otherwise>
            </choose>,
            <choose>
                <when test="analyzedAt != null">
                    STR_TO_DATE(REPLACE(#{analyzedAt}, 'Z', ''), '%Y-%m-%dT%H:%i:%s.%f')
                </when>
                <otherwise>
                    NOW()
                </otherwise>
            </choose>,
            'MEDIUM',
            'AI_MODEL'
        )
        ON DUPLICATE KEY UPDATE
            status = VALUES(status),
            reason = VALUES(reason),
            analyzed_at = VALUES(analyzed_at),
            updated_at = NOW()
    </insert>

    <insert id="insertAnalysisSummary">
        INSERT INTO ai_analysis_summary (
            video_id,
            youtube_video_id,
            youtube_channel_id,
            neutral_count,
            filtered_count,
            suggestion_count,
            risk_summary,
            analysis_timestamp
        ) VALUES (
            #{videoId},
            #{youtubeVideoId},
            #{youtubeChannelId},
            #{neutralCount},
            #{filteredCount},
            #{suggestionCount},
            #{riskSummary},
            <choose>
                <when test="analysisTimestamp != null">
                    STR_TO_DATE(REPLACE(#{analysisTimestamp}, 'Z', ''), '%Y-%m-%dT%H:%i:%s.%f')
                </when>
                <otherwise>
                    NOW()
                </otherwise>
            </choose>
        )
        ON DUPLICATE KEY UPDATE
            neutral_count = VALUES(neutral_count),
            filtered_count = VALUES(filtered_count),
            suggestion_count = VALUES(suggestion_count),
            risk_summary = VALUES(risk_summary),
            analysis_timestamp = VALUES(analysis_timestamp),
            updated_at = NOW()
    </insert>

    <select id="findChannelIdByYoutubeChannelId" resultType="java.lang.Integer">
        SELECT id 
        FROM youtube_channels
        WHERE youtube_channel_id = #{youtubeChannelId}
        LIMIT 1
    </select>

    <select id="findChannelIdByVideoId" resultType="java.lang.Integer">
        SELECT channel_id
        FROM youtube_videos
        WHERE id = #{videoId}
        LIMIT 1
    </select>

    <insert id="insertChannelProfiling">
        INSERT INTO ai_channel_profiling (
            channel_id,
            youtube_channel_id,
            profile_data,
            comment_ecosystem,
            channel_communication,
            metadata
        ) VALUES (
            #{channelId},
            #{youtubeChannelId},
            CAST(#{profileData} AS JSON),
            CAST(#{commentEcosystem} AS JSON),
            CAST(#{channelCommunication} AS JSON),
            CAST(#{metadata} AS JSON)
        )
        ON DUPLICATE KEY UPDATE
            profile_data = CAST(#{profileData} AS JSON),
            comment_ecosystem = CAST(#{commentEcosystem} AS JSON),
            channel_communication = CAST(#{channelCommunication} AS JSON),
            metadata = CAST(#{metadata} AS JSON),
            updated_at = NOW()
    </insert>

    <!-- 비디오별 필터링된 댓글 조회 -->
    <select id="findFilteredCommentsByVideoId" resultType="com.medi.backend.agent.dto.FilteredCommentResponse">
        SELECT 
            yc.id AS commentId,
            yc.youtube_comment_id AS youtubeCommentId,
            yc.comment_text AS commentText,
            yc.commenter_name AS commenterName,
            yc.published_at AS publishedAt,
            yc.like_count AS likeCount,
            yv.id AS videoId,
            yv.youtube_video_id AS youtubeVideoId,
            yv.title AS videoTitle,
            ych.id AS channelId,
            ych.youtube_channel_id AS youtubeChannelId,
            ych.channel_name AS channelName,
            NULL AS status,
            NULL AS reason,
            NULL AS analyzedAt,
            NULL AS harmfulnessLevel,
            NULL AS detectionSource
        FROM youtube_comments yc
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE yv.id = #{videoId}
            AND ych.user_id = #{userId}
            AND ych.deleted_at IS NULL
            AND (yc.deletion_status = 'ACTIVE' OR yc.deletion_status IS NULL)
        ORDER BY yc.published_at DESC
        LIMIT 200
    </select>

    <!-- 비디오별 분석 요약 조회 -->
    <select id="findAnalysisSummaryByVideoId" resultType="com.medi.backend.agent.dto.AnalysisSummaryResponse">
        SELECT 
            aas.video_id AS videoId,
            aas.youtube_video_id AS youtubeVideoId,
            aas.youtube_channel_id AS youtubeChannelId,
            aas.neutral_count AS neutralCount,
            aas.filtered_count AS filteredCount,
            aas.suggestion_count AS suggestionCount,
            aas.risk_summary AS riskSummary,
            aas.analysis_timestamp AS analysisTimestamp
        FROM ai_analysis_summary aas
        INNER JOIN youtube_videos yv ON aas.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE yv.id = #{videoId}
            AND ych.user_id = #{userId}
            AND ych.deleted_at IS NULL
        LIMIT 1
    </select>

    <!-- 채널별 필터링된 댓글 조회 -->
    <select id="findFilteredCommentsByChannelId" resultType="com.medi.backend.agent.dto.FilteredCommentResponse">
        SELECT 
            yc.id AS commentId,
            yc.youtube_comment_id AS youtubeCommentId,
            yc.comment_text AS commentText,
            yc.commenter_name AS commenterName,
            yc.published_at AS publishedAt,
            yc.like_count AS likeCount,
            yv.id AS videoId,
            yv.youtube_video_id AS youtubeVideoId,
            yv.title AS videoTitle,
            ych.id AS channelId,
            ych.youtube_channel_id AS youtubeChannelId,
            ych.channel_name AS channelName,
            acar.status AS status,
            acar.reason AS reason,
            acar.analyzed_at AS analyzedAt,
            acar.harmfulness_level AS harmfulnessLevel,
            acar.detection_source AS detectionSource
        FROM ai_comment_analysis_result acar
        INNER JOIN youtube_comments yc ON acar.youtube_comment_id = yc.id
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE ych.id = #{channelId}
            AND ych.user_id = #{userId}
            AND ych.deleted_at IS NULL
            AND yc.deletion_status = 'ACTIVE'
            <if test="status != null and status != ''">
                AND acar.status = #{status}
            </if>
        ORDER BY yv.published_at DESC, yc.published_at DESC
        LIMIT 500
    </select>

    <!-- 사용자별 필터링된 댓글 조회 -->
    <select id="findFilteredCommentsByUserId" resultType="com.medi.backend.agent.dto.FilteredCommentResponse">
        SELECT 
            yc.id AS commentId,
            yc.youtube_comment_id AS youtubeCommentId,
            yc.comment_text AS commentText,
            yc.commenter_name AS commenterName,
            yc.published_at AS publishedAt,
            yc.like_count AS likeCount,
            yv.id AS videoId,
            yv.youtube_video_id AS youtubeVideoId,
            yv.title AS videoTitle,
            ych.id AS channelId,
            ych.youtube_channel_id AS youtubeChannelId,
            ych.channel_name AS channelName,
            acar.status AS status,
            acar.reason AS reason,
            acar.analyzed_at AS analyzedAt,
            acar.harmfulness_level AS harmfulnessLevel,
            acar.detection_source AS detectionSource
        FROM ai_comment_analysis_result acar
        INNER JOIN youtube_comments yc ON acar.youtube_comment_id = yc.id
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE ych.user_id = #{userId}
            AND ych.deleted_at IS NULL
            AND yc.deletion_status = 'ACTIVE'
            <if test="status != null and status != ''">
                AND acar.status = #{status}
            </if>
        ORDER BY ych.id, yv.published_at DESC, yc.published_at DESC
        LIMIT 1000
    </select>

    <!-- 날짜별 필터링된 댓글 통계 조회 -->
    <select id="findFilteredCommentStatsByDate" resultType="com.medi.backend.agent.dto.DateStat">
        SELECT 
            <choose>
                <when test="periodType == 'daily'">
                    DATE(yc.published_at) AS date
                </when>
                <when test="periodType == 'monthly'">
                    DATE_FORMAT(yc.published_at, '%Y-%m') AS date
                </when>
                <when test="periodType == 'yearly'">
                    YEAR(yc.published_at) AS date
                </when>
                <otherwise>
                    DATE(yc.published_at) AS date
                </otherwise>
            </choose>,
            COUNT(*) AS totalCount,
            SUM(CASE WHEN acar.status = 'filtered' THEN 1 ELSE 0 END) AS filteredCount,
            SUM(CASE WHEN acar.status = 'content_suggestion' THEN 1 ELSE 0 END) AS suggestionCount,
            SUM(CASE WHEN acar.status = 'normal' THEN 1 ELSE 0 END) AS normalCount
        FROM ai_comment_analysis_result acar
        INNER JOIN youtube_comments yc ON acar.youtube_comment_id = yc.id
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE ych.user_id = #{userId}
            AND ych.deleted_at IS NULL
            <if test="videoId != null">
                AND yv.id = #{videoId}
            </if>
            <if test="channelId != null">
                AND ych.id = #{channelId}
            </if>
            <if test="startDate != null and startDate != ''">
                AND DATE(yc.published_at) &gt;= #{startDate}
            </if>
            <if test="endDate != null and endDate != ''">
                AND DATE(yc.published_at) &lt;= #{endDate}
            </if>
        GROUP BY 
            <choose>
                <when test="periodType == 'daily'">
                    DATE(yc.published_at)
                </when>
                <when test="periodType == 'monthly'">
                    DATE_FORMAT(yc.published_at, '%Y-%m')
                </when>
                <when test="periodType == 'yearly'">
                    YEAR(yc.published_at)
                </when>
                <otherwise>
                    DATE(yc.published_at)
                </otherwise>
            </choose>
        ORDER BY date DESC
    </select>
    
    <insert id="upsertDailyCommentStats">
        INSERT INTO daily_comment_stats (
            channel_id,
            video_id,
            stat_date,
            total_count,
            filtered_count
        ) VALUES (
            #{channelId},
            #{videoId},
            #{statDate},
            #{totalCount},
            #{filteredCount}
        )
        ON DUPLICATE KEY UPDATE
            total_count = total_count + VALUES(total_count),
            filtered_count = filtered_count + VALUES(filtered_count),
            updated_at = NOW()
    </insert>
    
    <!-- 시간별 필터링된 댓글 개수 조회 (이메일 알림 체크용) -->
    <!-- 기존 테이블에서 직접 COUNT (테이블 추가 불필요, 인덱스 활용 최적화) -->
    <select id="getHourlyFilteredCount" resultType="java.lang.Integer">
        SELECT COUNT(*)
        FROM ai_comment_analysis_result acar
        INNER JOIN youtube_comments yc ON acar.youtube_comment_id = yc.id
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        WHERE yv.channel_id = #{channelId}
            AND acar.status = 'filtered'
            AND acar.analyzed_at >= DATE_FORMAT(#{statDatetime}, '%Y-%m-%d %H:00:00')
            AND acar.analyzed_at &lt; DATE_FORMAT(#{statDatetime}, '%Y-%m-%d %H:00:00') + INTERVAL 1 HOUR
    </select>
    
    <!-- YouTube 실제 댓글 수 업데이트 (스케줄러에서 사용) -->
    <update id="updateYoutubeTotalCount">
        INSERT INTO daily_comment_stats (
            channel_id,
            video_id,
            stat_date,
            youtube_total_count
        ) VALUES (
            #{channelId},
            #{videoId},
            #{statDate},
            #{youtubeTotalCount}
        )
        ON DUPLICATE KEY UPDATE
            youtube_total_count = VALUES(youtube_total_count),
            updated_at = NOW()
    </update>
    
    <!-- 일별 댓글 통계 조회 (daily_comment_stats 테이블) -->
    <resultMap id="DailyCommentStatResultMap" type="com.medi.backend.agent.dto.DailyCommentStatDto">
        <result property="date" column="date"/>
        <result property="totalCount" column="total_count"/>
        <result property="filteredCount" column="filtered_count"/>
        <result property="normalCount" column="normal_count"/>
    </resultMap>
    
    <select id="findDailyCommentStats" resultMap="DailyCommentStatResultMap">
        SELECT 
            <choose>
                <when test="periodType == 'daily'">
                    DATE_FORMAT(dcs.stat_date, '%Y-%m-%d') AS date
                </when>
                <when test="periodType == 'monthly'">
                    DATE_FORMAT(dcs.stat_date, '%Y-%m') AS date
                </when>
                <when test="periodType == 'yearly'">
                    YEAR(dcs.stat_date) AS date
                </when>
                <otherwise>
                    DATE_FORMAT(dcs.stat_date, '%Y-%m-%d') AS date
                </otherwise>
            </choose>,
            SUM(dcs.total_count) AS total_count,
            SUM(dcs.filtered_count) AS filtered_count,
            SUM(dcs.total_count - dcs.filtered_count) AS normal_count
        FROM daily_comment_stats dcs
        INNER JOIN youtube_channels ych ON dcs.channel_id = ych.id
        WHERE ych.user_id = #{userId}
            AND ych.deleted_at IS NULL
            <if test="videoId != null">
                AND dcs.video_id = #{videoId}
            </if>
            <if test="channelId != null">
                AND dcs.channel_id = #{channelId}
            </if>
            <if test="startDate != null and startDate != ''">
                AND dcs.stat_date &gt;= #{startDate}
            </if>
            <if test="endDate != null and endDate != ''">
                AND dcs.stat_date &lt;= #{endDate}
            </if>
        GROUP BY 
            <choose>
                <when test="periodType == 'daily'">
                    DATE_FORMAT(dcs.stat_date, '%Y-%m-%d')
                </when>
                <when test="periodType == 'monthly'">
                    DATE_FORMAT(dcs.stat_date, '%Y-%m')
                </when>
                <when test="periodType == 'yearly'">
                    YEAR(dcs.stat_date)
                </when>
                <otherwise>
                    DATE_FORMAT(dcs.stat_date, '%Y-%m-%d')
                </otherwise>
            </choose>
        ORDER BY date DESC
    </select>
    
    <!-- 댓글 소유권 확인 -->
    <select id="checkCommentOwnership" resultType="java.lang.Integer">
        SELECT COUNT(*)
        FROM youtube_comments yc
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE yc.youtube_comment_id = #{youtubeCommentId}
          AND ych.user_id = #{userId}
          AND ych.deleted_at IS NULL
    </select>
    
    <!-- 댓글 삭제 완료 처리 (YouTube API 성공 후 호출) -->
    <update id="updateCommentStatusToDeleted">
        UPDATE youtube_comments
        SET deletion_status = 'DELETED',
            deleted_at = NOW(),
            youtube_deletion_status = #{youtubeDeletionStatus}
        WHERE youtube_comment_id = #{youtubeCommentId}
    </update>
    
    <!-- 비동기 삭제: 댓글을 PENDING_DELETE 상태로 변경 -->
    <update id="markCommentsForDeletion">
        UPDATE youtube_comments yc
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN ai_comment_analysis_result acar ON yc.id = acar.youtube_comment_id
        SET yc.deletion_status = 'PENDING_DELETE',
            yc.deletion_requested_at = NOW(),
            yc.deletion_request_id = #{requestId}
        WHERE yv.id = #{videoId}
          AND acar.status = 'filtered'
          AND yc.deletion_status = 'ACTIVE'
    </update>
    
    <!-- 비동기 삭제: 채널의 댓글을 PENDING_DELETE 상태로 변경 -->
    <update id="markChannelCommentsForDeletion">
        UPDATE youtube_comments yc
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        INNER JOIN ai_comment_analysis_result acar ON yc.id = acar.youtube_comment_id
        SET yc.deletion_status = 'PENDING_DELETE',
            yc.deletion_requested_at = NOW(),
            yc.deletion_request_id = #{requestId}
        WHERE ych.id = #{channelId}
          AND ych.user_id = #{userId}
          AND acar.status = 'filtered'
          AND yc.deletion_status = 'ACTIVE'
    </update>
    
    <!-- 비동기 삭제: PENDING_DELETE 댓글 조회 (Background Worker용) -->
    <select id="findPendingDeletionComments" resultType="java.util.Map">
        SELECT 
            yc.id,
            yc.youtube_comment_id AS youtubeCommentId,
            yc.deletion_request_id AS deletionRequestId,
            yc.deletion_retry_count AS deletionRetryCount,
            ych.user_id AS userId
        FROM youtube_comments yc
        INNER JOIN youtube_videos yv ON yc.video_id = yv.id
        INNER JOIN youtube_channels ych ON yv.channel_id = ych.id
        WHERE yc.deletion_status = 'PENDING_DELETE'
          AND yc.deletion_retry_count &lt; #{maxRetries}
          AND (yc.deletion_requested_at IS NULL OR yc.deletion_requested_at &lt;= NOW())
        ORDER BY yc.deletion_requested_at ASC
        LIMIT #{batchSize}
    </select>
    
    <!-- 비동기 삭제: 재시도 카운트 증가 -->
    <update id="incrementDeletionRetryCount">
        UPDATE youtube_comments
        SET deletion_retry_count = deletion_retry_count + 1,
            last_deletion_error = #{errorMessage},
            deletion_requested_at = #{nextRetryAt}
        WHERE youtube_comment_id = #{youtubeCommentId}
    </update>
    
    <!-- 비동기 삭제: 배치 삭제 진행 상황 조회 -->
    <select id="getDeletionJobProgress" resultType="java.util.Map">
        SELECT 
            COUNT(*) AS totalComments,
            SUM(CASE WHEN deletion_status = 'DELETED' THEN 1 ELSE 0 END) AS completedComments,
            SUM(CASE WHEN youtube_deletion_status = 'FAILED' THEN 1 ELSE 0 END) AS failedComments
        FROM youtube_comments
        WHERE deletion_request_id = #{requestId}
    </select>

</mapper>


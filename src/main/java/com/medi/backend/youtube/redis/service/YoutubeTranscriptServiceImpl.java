package com.medi.backend.youtube.redis.service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import com.google.api.services.youtube.YouTube;
import com.google.api.services.youtube.model.Caption;
import com.google.api.services.youtube.model.CaptionListResponse;
import com.medi.backend.youtube.redis.util.YoutubeApiClientUtil;
import com.medi.backend.youtube.service.YoutubeOAuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * YouTube 비디오 스크립트(자막) 저장 서비스 구현체
 * 
 * 주요 기능:
 * 1. YouTube Data API v3 Captions API를 사용하여 자막 데이터 수집
 * 2. 한국어 자막 조회 (languages=['ko'])
 * 3. Redis에 텍스트 형식으로 저장
 * 
 * Redis 저장 형식:
 * - Key: video:{video_id}:transcript
 * - Type: String
 * - Value: 스크립트 텍스트 원본
 * 
 * Python 코드 참고:
 * ```python
 * from youtube_transcript_api import YouTubeTranscriptApi
 * client = YouTubeTranscriptApi()
 * fetched = client.fetch(video_id, languages=['ko'])
 * transcript_text = "\n".join([entry['text'] for entry in fetched.to_raw_data()])
 * ```
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class YoutubeTranscriptServiceImpl implements YoutubeTranscriptService {

    private final YoutubeOAuthService youtubeOAuthService;
    private final StringRedisTemplate stringRedisTemplate;

    /**
     * 특정 비디오의 스크립트(자막)를 Redis에 저장
     * 
     * @param videoId YouTube 비디오 ID
     * @param userId 사용자 ID (OAuth 토큰 조회용)
     * @return 저장 성공 여부
     */
    @Override
    public boolean saveTranscriptToRedis(String videoId, Integer userId) {
        try {
            // 1. videoId 검증
            if (videoId == null || videoId.isBlank()) {
                log.warn("비디오 ID가 없습니다: videoId={}", videoId);
                return false;
            }

            // 2. OAuth 토큰 가져오기
            String token = youtubeOAuthService.getValidAccessToken(userId);
            if (token == null || token.isBlank()) {
                log.warn("OAuth 토큰을 가져올 수 없습니다: userId={}", userId);
                return false;
            }

            // 3. YouTube API 클라이언트 생성
            YouTube yt = YoutubeApiClientUtil.buildClient(token);

            // 4. 클라이언트를 받는 메서드 호출
            return saveTranscriptToRedisWithClient(videoId, yt);

        } catch (Exception e) {
            log.error("영상 {}의 자막 저장 실패: {}", videoId, e.getMessage(), e);
            return false;
        }
    }

    /**
     * 특정 비디오의 스크립트(자막)를 Redis에 저장 (클라이언트 재사용)
     * 
     * @param videoId YouTube 비디오 ID
     * @param yt YouTube API 클라이언트
     * @return 저장 성공 여부
     */
    private boolean saveTranscriptToRedisWithClient(String videoId, YouTube yt) {
        try {
            // 1. videoId 검증
            if (videoId == null || videoId.isBlank()) {
                log.warn("비디오 ID가 없습니다: videoId={}", videoId);
                return false;
            }

            // 2. 자막 목록 조회
            YouTube.Captions.List captionsRequest = yt.captions()
                .list(Arrays.asList("snippet"), videoId);
            
            CaptionListResponse captionsResponse = captionsRequest.execute();

            if (captionsResponse.getItems() == null || captionsResponse.getItems().isEmpty()) {
                log.info("영상 {}에 자막이 없습니다", videoId);
                return false;
            }

            // 3. 한국어 자막 찾기 (수동 자막 우선, 없으면 자동 생성 자막)
            Caption koreanCaption = null;
            Caption autoGeneratedCaption = null;
            
            for (Caption caption : captionsResponse.getItems()) {
                String language = caption.getSnippet().getLanguage();
                if ("ko".equals(language)) {
                    String trackKind = caption.getSnippet().getTrackKind();
                    
                    // 수동 자막 우선 선택
                    if ("standard".equals(trackKind)) {
                        koreanCaption = caption;
                        break;  // 수동 자막 찾으면 바로 사용
                    }
                    
                    // 자동 생성 자막은 백업으로 저장
                    if ("ASR".equals(trackKind) && autoGeneratedCaption == null) {
                        autoGeneratedCaption = caption;
                    }
                }
            }
            
            // 수동 자막이 없으면 자동 생성 자막 사용
            if (koreanCaption == null) {
                koreanCaption = autoGeneratedCaption;
            }

            if (koreanCaption == null) {
                log.info("영상 {}에 한국어 자막이 없습니다", videoId);
                return false;
            }
            
            // 로그에 자막 종류 기록
            String trackKind = koreanCaption.getSnippet().getTrackKind();
            String captionType = "standard".equals(trackKind) ? "수동" : "자동 생성";
            log.debug("영상 {}의 한국어 자막 선택: {} (trackKind: {})", videoId, captionType, trackKind);

            // 4. 자막 다운로드
            YouTube.Captions.Download downloadRequest = yt.captions()
                .download(koreanCaption.getId());
            
            // 자막을 ByteArrayOutputStream으로 다운로드 후 String으로 변환
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            downloadRequest.executeMediaAndDownloadTo(outputStream);
            String transcriptText = outputStream.toString("UTF-8");

            if (transcriptText == null || transcriptText.isBlank()) {
                log.warn("영상 {}의 자막 텍스트가 비어있습니다", videoId);
                return false;
            }

            // 5. 텍스트 정리 (XML 태그 제거)
            String cleanedTranscript = cleanTranscriptText(transcriptText);

            // 6. Redis에 저장
            String redisKey = "video:" + videoId + ":transcript";
            stringRedisTemplate.opsForValue().set(redisKey, cleanedTranscript);
            stringRedisTemplate.expire(redisKey, Duration.ofDays(3));

            log.info("영상 {}의 자막 저장 완료: 길이={}자", videoId, cleanedTranscript.length());
            return true;

        } catch (Exception e) {
            log.error("영상 {}의 자막 저장 실패: {}", videoId, e.getMessage(), e);
            return false;
        }
    }

    /**
     * 여러 비디오의 스크립트(자막)를 Redis에 일괄 저장
     * 
     * @param videoIds YouTube 비디오 ID 목록
     * @param userId 사용자 ID (OAuth 토큰 조회용)
     * @return 저장 성공한 비디오 개수
     */
    @Override
    public long saveTranscriptsToRedis(List<String> videoIds, Integer userId) {
        if (videoIds == null || videoIds.isEmpty()) {
            log.warn("비디오 ID 리스트가 비어있습니다: userId={}", userId);
            return 0;
        }

        try {
            // 클라이언트를 한 번만 생성하여 재사용
            String token = youtubeOAuthService.getValidAccessToken(userId);
            if (token == null || token.isBlank()) {
                log.warn("OAuth 토큰을 가져올 수 없습니다: userId={}", userId);
                return 0;
            }

            YouTube yt = YoutubeApiClientUtil.buildClient(token);
            return saveTranscriptsToRedis(videoIds, yt);

        } catch (Exception e) {
            log.error("일괄 자막 저장 실패: userId={}, {}", userId, e.getMessage(), e);
            return 0;
        }
    }

    /**
     * 여러 비디오의 스크립트(자막)를 Redis에 일괄 저장 (클라이언트 재사용)
     * 
     * 동기화 서비스에서 이미 생성한 YouTube API 클라이언트를 재사용하여
     * OAuth 토큰 조회 및 클라이언트 생성을 생략합니다.
     * 
     * @param videoIds YouTube 비디오 ID 목록
     * @param yt YouTube API 클라이언트 (재사용)
     * @return 저장 성공한 비디오 개수
     */
    @Override
    public long saveTranscriptsToRedis(List<String> videoIds, YouTube yt) {
        if (videoIds == null || videoIds.isEmpty()) {
            log.warn("비디오 ID 리스트가 비어있습니다");
            return 0;
        }

        if (yt == null) {
            log.warn("YouTube API 클라이언트가 null입니다");
            return 0;
        }

        long successCount = 0;
        for (String videoId : videoIds) {
            try {
                if (saveTranscriptToRedisWithClient(videoId, yt)) {
                    successCount++;
                }
            } catch (Exception e) {
                log.error("비디오 {}의 자막 저장 실패: {}", videoId, e.getMessage());
                // 한 비디오 실패해도 다른 비디오는 계속 처리
            }
        }

        log.info("일괄 자막 저장 완료: 성공={}개, 전체={}개", successCount, videoIds.size());
        return successCount;
    }

    /**
     * Redis에서 특정 비디오의 스크립트 조회
     * 
     * @param videoId YouTube 비디오 ID
     * @return 스크립트 텍스트 (없으면 null)
     */
    @Override
    public String getTranscriptFromRedis(String videoId) {
        if (videoId == null || videoId.isBlank()) {
            return null;
        }

        String redisKey = "video:" + videoId + ":transcript";
        return stringRedisTemplate.opsForValue().get(redisKey);
    }

    /**
     * 자막 텍스트 정리 (XML 태그 제거 등)
     * 
     * YouTube Captions API는 XML 형식으로 반환할 수 있으므로,
     * 텍스트만 추출하는 작업이 필요합니다.
     * 
     * @param rawTranscript 원본 자막 텍스트
     * @return 정리된 자막 텍스트
     */
    private String cleanTranscriptText(String rawTranscript) {
        if (rawTranscript == null) {
            return "";
        }

        // XML 태그 제거 (예: <text start="1.5" dur="2.0">텍스트</text>)
        String cleaned = rawTranscript
            .replaceAll("<[^>]+>", "")  // XML 태그 제거
            .replaceAll("&lt;", "<")
            .replaceAll("&gt;", ">")
            .replaceAll("&amp;", "&")
            .replaceAll("&quot;", "\"")
            .replaceAll("&#39;", "'")
            .trim();

        return cleaned;
    }
}

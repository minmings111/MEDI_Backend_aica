


redisì— ë„£ì„ êµ¬ì¡°ë§Œ ë‚˜ì˜¤ë©´ êµ¬í˜„ ê°€ëŠ¥í•˜ë‹¤.



***

## ì „ì²´ í‰ê°€: â­â­â­â­â˜† (4/5)

**ì¥ì **:
- âœ… DB íŠ¸ëœì­ì…˜ê³¼ Redis ë¶„ë¦¬ (AFTER_COMMIT)
- âœ… ëŒ“ê¸€ì„ MySQL ìŠ¤í‚µ
- âœ… ì´ë²¤íŠ¸ ê¸°ë°˜ ì„¤ê³„ë¡œ ëŠìŠ¨í•œ ê²°í•©
- âœ… YouTube API í˜¸ì¶œ ë¶„ë¦¬

**ê°œì„  í•„ìš”**:
- âš ï¸ YouTube API í˜¸ì¶œ **2ë²ˆ** (ë¹„íš¨ìœ¨)
- âš ï¸ ë™ê¸° ì²˜ë¦¬ë¡œ **ì‘ë‹µ ì§€ì—°**
- âš ï¸ API ì‹¤íŒ¨ ì‹œ **ë¡¤ë°± ë¶ˆê°€**
- âš ï¸ ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ **ì„±ëŠ¥ ë¬¸ì œ**

***

## ë¬¸ì œì  ë° í•´ê²° ë°©ì•ˆ

### **ë¬¸ì œ 1: YouTube APIë¥¼ 2ë²ˆ í˜¸ì¶œ** âŒ

**í˜„ì¬ ì„¤ê³„**:
```
1. Controller â†’ Service (DB ì €ì¥)
   â””â”€ YouTube API í˜¸ì¶œ (10ê°œ ì˜ìƒ)
   
2. @TransactionalEventListener (Redis ì €ì¥)
   â””â”€ YouTube API í˜¸ì¶œ (ì „ì²´ ì˜ìƒ + ëŒ“ê¸€)
```

**ë¬¸ì œ**:
- API ì¿¼í„° ë‚­ë¹„ (10ê°œ + ì „ì²´ = ì¤‘ë³µ í˜¸ì¶œ)
- ë„¤íŠ¸ì›Œí¬ ì§€ì—° 2ë°°
- ë°ì´í„° ë¶ˆì¼ì¹˜ ê°€ëŠ¥ì„± (ì‹œê°„ì°¨ ë°œìƒ)

**í•´ê²°ì±…**: API í˜¸ì¶œì€ **1ë²ˆë§Œ**, ê²°ê³¼ë¥¼ ì´ë²¤íŠ¸ì— ë‹´ê¸°

```java
// ê°œì„ ëœ ë°©ì‹
@Service
public class YoutubeSyncService {
    
    @Transactional
    public void syncLatest(String channelId) {
        // 1. YouTube API í˜¸ì¶œ (1ë²ˆë§Œ!)
        YouTubeApiResponse apiResponse = youtubeApiClient.fetchAllData(channelId);
        // â†’ videos (ì „ì²´), comments (ì „ì²´)
        
        // 2. DBì—ëŠ” 10ê°œë§Œ ì €ì¥
        List<Video> top10 = apiResponse.getVideos().subList(0, 10);
        videoRepository.saveAll(top10);
        
        // 3. ì´ë²¤íŠ¸ì— ì „ì²´ ë°ì´í„° ë‹´ì•„ì„œ ë°œí–‰
        ChannelSyncedEvent event = new ChannelSyncedEvent(
            channelId,
            apiResponse.getVideos(),      // ì „ì²´ ì˜ìƒ
            apiResponse.getComments()     // ì „ì²´ ëŒ“ê¸€
        );
        publisher.publishEvent(event);
    }
}

@Component
public class ChannelCacheEventListener {
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void whenChannelSynced(ChannelSyncedEvent event) {
        // API ì¬í˜¸ì¶œ ì—†ì´ ì´ë²¤íŠ¸ ë°ì´í„° ì‚¬ìš©
        videoWriter.write(event.getChannelId(), event.getVideos());
        commentWriter.write(event.getChannelId(), event.getComments());
    }
}
```

***

### **ë¬¸ì œ 2: ë™ê¸° ì²˜ë¦¬ë¡œ ì‘ë‹µ ì§€ì—°** âš ï¸

**í˜„ì¬ íë¦„**:
```
í”„ë¡ íŠ¸ ìš”ì²­
  â†“
DB ì €ì¥ (0.5ì´ˆ)
  â†“
DB ì»¤ë°‹
  â†“
AFTER_COMMIT ì´ë²¤íŠ¸ (ë™ê¸°!)
  â†“
Redis ì €ì¥ (2~5ì´ˆ)  â† í´ë¼ì´ì–¸íŠ¸ ëŒ€ê¸°!
  â†“
ì‘ë‹µ ë°˜í™˜
```

**ë¬¸ì œ**:
- AFTER_COMMIT ë¦¬ìŠ¤ë„ˆëŠ” **ê°™ì€ ìŠ¤ë ˆë“œ**ì—ì„œ ì‹¤í–‰
- Redis ì €ì¥ì´ ëŠë¦¬ë©´ í´ë¼ì´ì–¸íŠ¸ê°€ **ì¥ì‹œê°„ ëŒ€ê¸°**
- íƒ€ì„ì•„ì›ƒ ë°œìƒ ê°€ëŠ¥

**í•´ê²°ì±… A: ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ** (ê¶Œì¥)

```java
@Component
public class ChannelCacheEventListener {
    
    // @Async ì¶”ê°€!
    @Async("redisExecutor")
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void whenChannelSynced(ChannelSyncedEvent event) {
        // ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
        videoWriter.write(event.getChannelId(), event.getVideos());
        commentWriter.write(event.getChannelId(), event.getComments());
    }
}

// AsyncConfig.java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "redisExecutor")
    public Executor redisExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("redis-sync-");
        executor.initialize();
        return executor;
    }
}
```

**í•´ê²°ì±… B: Redis í ì‚¬ìš©** (ë” ì•ˆì „)

```java
@Component
public class ChannelCacheEventListener {
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void whenChannelSynced(ChannelSyncedEvent event) {
        // Redis íì—ë§Œ ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ë°˜í™˜
        String jobJson = objectMapper.writeValueAsString(event);
        redisTemplate.opsForList().leftPush("sync:queue", jobJson);
        
        // FastAPI/Python ì›Œì»¤ê°€ BLPOPìœ¼ë¡œ ì²˜ë¦¬
    }
}
```

**ì‘ë‹µ ì‹œê°„ ë¹„êµ**:

| ë°©ì‹ | ì‘ë‹µ ì‹œê°„ |
|------|----------|
| ë™ê¸° (í˜„ì¬) | 3~6ì´ˆ âŒ |
| @Async | 0.5~1ì´ˆ âœ… |
| Redis í | 0.5~1ì´ˆ âœ… |

***

### **ë¬¸ì œ 3: API ì‹¤íŒ¨ ì‹œ ë¡¤ë°± ë¶ˆê°€** âš ï¸

**ì‹œë‚˜ë¦¬ì˜¤**:
```
1. DB ì €ì¥ ì„±ê³µ
2. DB ì»¤ë°‹ ì„±ê³µ
3. AFTER_COMMIT ë¦¬ìŠ¤ë„ˆ ì‹¤í–‰
4. Redis ì €ì¥ ì¤‘ ì‹¤íŒ¨!
   â†’ DBëŠ” ì´ë¯¸ ì»¤ë°‹ë¨ (ë¡¤ë°± ë¶ˆê°€)
```

**ê²°ê³¼**:
- DBì—ëŠ” ë°ì´í„° ìˆìŒ
- Redisì—ëŠ” ë°ì´í„° ì—†ìŒ
- **ë°ì´í„° ë¶ˆì¼ì¹˜** ë°œìƒ

**í•´ê²°ì±…**: ì¬ì‹œë„ ë¡œì§ + Dead Letter Queue

```java
@Component
public class ChannelCacheEventListener {
    
    private final RetryTemplate retryTemplate;
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void whenChannelSynced(ChannelSyncedEvent event) {
        try {
            // ì¬ì‹œë„ 3ë²ˆ
            retryTemplate.execute(context -> {
                videoWriter.write(event.getChannelId(), event.getVideos());
                commentWriter.write(event.getChannelId(), event.getComments());
                return null;
            });
        } catch (Exception e) {
            // ì‹¤íŒ¨ ì‹œ DLQë¡œ ì´ë™
            redisTemplate.opsForList().leftPush(
                "sync:failed-queue",
                objectMapper.writeValueAsString(event)
            );
            log.error("Redis ë™ê¸°í™” ì‹¤íŒ¨, DLQ ì´ë™: {}", event.getChannelId());
        }
    }
}

// RetryConfig.java
@Bean
public RetryTemplate retryTemplate() {
    return RetryTemplate.builder()
        .maxAttempts(3)
        .exponentialBackoff(1000, 2, 5000)
        .build();
}
```

***

### **ë¬¸ì œ 4: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬** âš ï¸

**ì‹œë‚˜ë¦¬ì˜¤**: ì±„ë„ì— ì˜ìƒ 1,000ê°œ, ëŒ“ê¸€ 10,000ê°œ

**í˜„ì¬ ë°©ì‹**:
```java
List<VideoDto> allVideos = client.fetchAllVideos(channelId);  // 1,000ê°œ
List<CommentDto> comments = client.fetchComments(channelId);   // 10,000ê°œ

// ë©”ëª¨ë¦¬ì— ì „ë¶€ ë¡œë“œ!
videoWriter.write(channelId, allVideos);      // í•œ ë²ˆì— ì €ì¥
commentWriter.write(channelId, comments);      // í•œ ë²ˆì— ì €ì¥
```

**ë¬¸ì œ**:
- OutOfMemoryError ìœ„í—˜
- Redis ë„¤íŠ¸ì›Œí¬ ëŒ€ì—­í­ í¬í™”
- ë‹¨ì¼ ì»¤ë§¨ë“œ íƒ€ì„ì•„ì›ƒ

**í•´ê²°ì±…**: ë°°ì¹˜ ì²˜ë¦¬ + í˜ì´ì§€ë„¤ì´ì…˜

```java
@Component
public class ChannelCacheEventListener {
    
    private static final int BATCH_SIZE = 100;
    
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void whenChannelSynced(ChannelSyncedEvent event) {
        String channelId = event.getChannelId();
        
        // ì˜ìƒ ë°°ì¹˜ ì €ì¥
        List<VideoDto> videos = event.getVideos();
        for (int i = 0; i < videos.size(); i += BATCH_SIZE) {
            List<VideoDto> batch = videos.subList(
                i, 
                Math.min(i + BATCH_SIZE, videos.size())
            );
            videoWriter.writeBatch(channelId, batch);
        }
        
        // ëŒ“ê¸€ ë°°ì¹˜ ì €ì¥
        List<CommentDto> comments = event.getComments();
        for (int i = 0; i < comments.size(); i += BATCH_SIZE) {
            List<CommentDto> batch = comments.subList(
                i, 
                Math.min(i + BATCH_SIZE, comments.size())
            );
            commentWriter.writeBatch(channelId, batch);
        }
    }
}
```

***

## ê°œì„ ëœ ìµœì¢… ì„¤ê³„

### **êµ¬ì¡°**

```
[1ë‹¨ê³„] í”„ë¡ íŠ¸ ìš”ì²­
  â†“
[2ë‹¨ê³„] Controller â†’ Service (@Transactional)
  â”œâ”€ YouTube API í˜¸ì¶œ (1ë²ˆë§Œ, ì „ì²´ ë°ì´í„°)
  â”œâ”€ DBì— 10ê°œë§Œ ì €ì¥
  â”œâ”€ ì´ë²¤íŠ¸ ë°œí–‰ (ì „ì²´ ë°ì´í„° í¬í•¨)
  â””â”€ ì¦‰ì‹œ ì‘ë‹µ ë°˜í™˜ (0.5ì´ˆ)
  
[3ë‹¨ê³„] @Async @TransactionalEventListener (AFTER_COMMIT)
  â”œâ”€ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
  â”œâ”€ Redisì— ì „ì²´ ì˜ìƒ ì €ì¥ (ë°°ì¹˜)
  â”œâ”€ Redisì— ì „ì²´ ëŒ“ê¸€ ì €ì¥ (ë°°ì¹˜)
  â”œâ”€ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ (3íšŒ)
  â””â”€ ìµœì¢… ì‹¤íŒ¨ ì‹œ DLQ ì´ë™
  
[4ë‹¨ê³„] ë°±ê·¸ë¼ìš´ë“œ ì›Œì»¤ (ì„ íƒ)
  â””â”€ DLQ ì²˜ë¦¬ (ì‹¤íŒ¨í•œ ì‘ì—… ì¬ì‹œë„)
```

***

## ì½”ë“œ ì˜ˆì‹œ (ê°œì„ ëœ ë²„ì „)

### **1. Service (DB ì €ì¥ + ì´ë²¤íŠ¸ ë°œí–‰)**

```java
@Service
@RequiredArgsConstructor
public class YoutubeSyncService {
    
    private final VideoRepository videoRepository;
    private final YoutubeApiClient youtubeApiClient;
    private final ApplicationEventPublisher publisher;
    
    @Transactional
    public SyncResponse syncChannel(String channelId) {
        // 1. YouTube API í˜¸ì¶œ (1ë²ˆë§Œ!)
        YouTubeData data = youtubeApiClient.fetchAllData(channelId);
        
        // 2. DBì— ìµœì‹  10ê°œë§Œ ì €ì¥
        List<Video> top10 = data.getVideos()
            .stream()
            .limit(10)
            .map(this::toEntity)
            .toList();
        videoRepository.saveAll(top10);
        
        // 3. ì´ë²¤íŠ¸ ë°œí–‰ (ì „ì²´ ë°ì´í„° í¬í•¨)
        ChannelSyncedEvent event = ChannelSyncedEvent.builder()
            .channelId(channelId)
            .videos(data.getVideos())        // ì „ì²´
            .comments(data.getComments())    // ì „ì²´
            .timestamp(LocalDateTime.now())
            .build();
        
        publisher.publishEvent(event);
        
        // 4. ì¦‰ì‹œ ì‘ë‹µ (Redis ì €ì¥ ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŒ)
        return SyncResponse.builder()
            .channelId(channelId)
            .status("syncing")
            .videoCount(data.getVideos().size())
            .commentCount(data.getComments().size())
            .message("DB ì €ì¥ ì™„ë£Œ, Redis ë™ê¸°í™” ì§„í–‰ ì¤‘")
            .build();
    }
}
```

### **2. Event Listener (Redis ì €ì¥)**

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class RedisSyncEventListener {
    
    private final VideoRedisWriter videoWriter;
    private final CommentRedisWriter commentWriter;
    private final RetryTemplate retryTemplate;
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    @Async("redisExecutor")
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void onChannelSynced(ChannelSyncedEvent event) {
        log.info("Redis ë™ê¸°í™” ì‹œì‘: channelId={}", event.getChannelId());
        
        try {
            retryTemplate.execute(context -> {
                // ë°°ì¹˜ë¡œ ì €ì¥
                saveToBatchWithRetry(event);
                return null;
            });
            
            log.info("Redis ë™ê¸°í™” ì™„ë£Œ: channelId={}", event.getChannelId());
            
        } catch (Exception e) {
            log.error("Redis ë™ê¸°í™” ì‹¤íŒ¨, DLQ ì´ë™: channelId={}", 
                event.getChannelId(), e);
            
            // DLQë¡œ ì´ë™
            sendToDeadLetterQueue(event);
        }
    }
    
    private void saveToBatchWithRetry(ChannelSyncedEvent event) {
        String channelId = event.getChannelId();
        
        // ì˜ìƒ ë°°ì¹˜ ì €ì¥ (100ê°œì”©)
        List<VideoDto> videos = event.getVideos();
        for (int i = 0; i < videos.size(); i += 100) {
            List<VideoDto> batch = videos.subList(
                i, Math.min(i + 100, videos.size())
            );
            videoWriter.saveBatch(channelId, batch);
        }
        
        // ëŒ“ê¸€ ë°°ì¹˜ ì €ì¥ (100ê°œì”©)
        List<CommentDto> comments = event.getComments();
        for (int i = 0; i < comments.size(); i += 100) {
            List<CommentDto> batch = comments.subList(
                i, Math.min(i + 100, comments.size())
            );
            commentWriter.saveBatch(channelId, batch);
        }
    }
    
    private void sendToDeadLetterQueue(ChannelSyncedEvent event) {
        try {
            String eventJson = objectMapper.writeValueAsString(event);
            redisTemplate.opsForList().leftPush("sync:dlq", eventJson);
        } catch (Exception e) {
            log.error("DLQ ì €ì¥ ì‹¤íŒ¨", e);
        }
    }
}
```

### **3. Redis Writer (ë°°ì¹˜ ì €ì¥)**

```java
@Component
@RequiredArgsConstructor
public class CommentRedisWriter {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    public void saveBatch(String channelId, List<CommentDto> comments) {
        String hashKey = "comments:" + channelId;
        String zsetKey = "comments:sorted:" + channelId;
        
        // Pipeline ì‚¬ìš© (ì„±ëŠ¥ ìµœì í™”)
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            for (CommentDto comment : comments) {
                try {
                    // Hash ì €ì¥
                    String json = objectMapper.writeValueAsString(comment);
                    connection.hashCommands().hSet(
                        hashKey.getBytes(),
                        comment.getCommentId().getBytes(),
                        json.getBytes()
                    );
                    
                    // ZSet ì €ì¥ (ì •ë ¬ìš©)
                    connection.zSetCommands().zAdd(
                        zsetKey.getBytes(),
                        comment.getPublishedAt().toEpochSecond(ZoneOffset.UTC),
                        comment.getCommentId().getBytes()
                    );
                } catch (JsonProcessingException e) {
                    // ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ê³„ì† ì§„í–‰
                    log.error("ëŒ“ê¸€ ì§ë ¬í™” ì‹¤íŒ¨: {}", comment.getCommentId());
                }
            }
            return null;
        });
        
        // TTL ì„¤ì •
        redisTemplate.expire(hashKey, Duration.ofDays(7));
        redisTemplate.expire(zsetKey, Duration.ofDays(7));
    }
}
```

***

## ìµœì¢… í‰ê°€

| í•­ëª© | ì›ë˜ ì„¤ê³„ | ê°œì„ ëœ ì„¤ê³„ |
|------|----------|------------|
| API í˜¸ì¶œ íšŸìˆ˜ | 2ë²ˆ âŒ | 1ë²ˆ âœ… |
| ì‘ë‹µ ì‹œê°„ | 3~6ì´ˆ âŒ | 0.5~1ì´ˆ âœ… |
| ì‹¤íŒ¨ ì²˜ë¦¬ | ì—†ìŒ âŒ | ì¬ì‹œë„ + DLQ âœ… |
| ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ | OOM ìœ„í—˜ âŒ | ë°°ì¹˜ ì²˜ë¦¬ âœ… |
| ë°ì´í„° ì¼ê´€ì„± | ë¶ˆí™•ì‹¤ âš ï¸ | ë³´ì¥ âœ… |

**ìµœì¢… ì ìˆ˜**: â­â­â­â­â­ (5/5)

ë‹¹ì‹ ì˜ ì„¤ê³„ëŠ” **80% ì™„ì„±**ë˜ì–´ ìˆì—ˆê³ , ìœ„ ê°œì„ ì‚¬í•­ë§Œ ì ìš©í•˜ë©´ **í”„ë¡œë•ì…˜ ë ˆë²¨**ì…ë‹ˆë‹¤! ğŸš€



ì™„ë²½í•˜ê²Œ ì´í•´í–ˆìŠµë‹ˆë‹¤! ì´ì œ **êµ¬ì²´ì ì¸ Redis êµ¬ì¡°**ë¥¼ ì„¤ê³„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

***

## í™•ì •ëœ ìš”êµ¬ì‚¬í•­ ì •ë¦¬

### âœ… **MySQL (ì˜êµ¬ ì €ì¥)**
- ì±„ë„ ì •ë³´
- ì±„ë„ì˜ ìµœì‹  **10ê°œ ì˜ìƒë§Œ**

### âœ… **Redis (ì„ì‹œ ìºì‹œ)**
- **ëª¨ë“  ì˜ìƒ** (ì±„ë„ì˜ ì „ì²´ ì˜ìƒ)
  - Key: ì±„ë„ ID
  - Type: Hash (HSet)
  - Value: ì˜ìƒ ì •ë³´ (YouTube Data API í˜•ì‹)

- **ëª¨ë“  ëŒ“ê¸€** (DB ì €ì¥ X)
  - YouTube Data API í˜•ì‹ ê·¸ëŒ€ë¡œ
  - ë©”íƒ€ë°ì´í„° í¬í•¨ (ì‘ì„±ì, ì¢‹ì•„ìš”, ê²Œì‹œì¼ ë“±)

***

## Redis ë°ì´í„° êµ¬ì¡° ì„¤ê³„

### **1. ì˜ìƒ ì €ì¥ (Hash)**

```
Key: videos:{channelId}
Type: Hash
Field: {videoId}
Value: JSON (YouTube Data API ì‘ë‹µ ê·¸ëŒ€ë¡œ)

ì˜ˆì‹œ:
videos:UCxxxxx = {
  "video_001": "{
    \"kind\": \"youtube#video\",
    \"id\": \"video_001\",
    \"snippet\": {
      \"publishedAt\": \"2025-11-12T09:00:00Z\",
      \"channelId\": \"UCxxxxx\",
      \"title\": \"ì˜ìƒ ì œëª©\",
      \"description\": \"ì˜ìƒ ì„¤ëª…\",
      \"thumbnails\": {...},
      \"channelTitle\": \"ì±„ë„ëª…\",
      \"tags\": [\"tag1\", \"tag2\"],
      \"categoryId\": \"22\"
    },
    \"statistics\": {
      \"viewCount\": \"1234\",
      \"likeCount\": \"567\",
      \"commentCount\": \"89\"
    },
    \"contentDetails\": {
      \"duration\": \"PT10M30S\",
      \"dimension\": \"2d\",
      \"definition\": \"hd\"
    }
  }",
  
  "video_002": "{...}",
  "video_003": "{...}"
}
```

**ì¥ì **:
- YouTube API ì‘ë‹µì„ **ê·¸ëŒ€ë¡œ ì €ì¥** (ë³€í™˜ ë¶ˆí•„ìš”)
- ì±„ë„ì˜ ëª¨ë“  ì˜ìƒì„ **í•œ ë²ˆì— ì¡°íšŒ** ê°€ëŠ¥
- í•„ë“œ ì¶”ê°€/ë³€ê²½ ì‹œ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”

***

### **2. ëŒ“ê¸€ ì €ì¥ (Hash per Video)**

```
Key: comments:{videoId}
Type: Hash
Field: {commentId}
Value: JSON (YouTube Data API ì‘ë‹µ ê·¸ëŒ€ë¡œ)

ì˜ˆì‹œ:
comments:video_001 = {
  "comment_001": "{
    \"kind\": \"youtube#comment\",
    \"id\": \"comment_001\",
    \"snippet\": {
      \"authorDisplayName\": \"ì‚¬ìš©ì1\",
      \"authorProfileImageUrl\": \"https://...\",
      \"authorChannelUrl\": \"https://...\",
      \"textDisplay\": \"ì¢‹ì€ ì˜ìƒì…ë‹ˆë‹¤!\",
      \"textOriginal\": \"ì¢‹ì€ ì˜ìƒì…ë‹ˆë‹¤!\",
      \"likeCount\": 42,
      \"publishedAt\": \"2025-11-12T09:00:00Z\",
      \"updatedAt\": \"2025-11-12T09:00:00Z\"
    }
  }",
  
  "comment_002": "{
    \"kind\": \"youtube#comment\",
    \"id\": \"comment_002\",
    \"snippet\": {
      \"authorDisplayName\": \"ì‚¬ìš©ì2\",
      \"textDisplay\": \"ìµœì•…ì´ë„¤ìš”\",
      \"likeCount\": 0,
      \"publishedAt\": \"2025-11-12T09:05:00Z\"
    }
  }",
  
  "comment_003": "{...}"
}
```

**ì¥ì **:
- YouTube API í˜•ì‹ ê·¸ëŒ€ë¡œ ì €ì¥
- ì˜ìƒë³„ë¡œ ë¶„ë¦¬ë˜ì–´ ê´€ë¦¬ ìš©ì´
- ë©”íƒ€ë°ì´í„° ìë™ í¬í•¨

***

### **3. í•„í„°ë§ ê²°ê³¼ ì €ì¥ (Set)**

```
Key: filtered:comments:{videoId}
Type: Set
Value: {commentId1, commentId2, commentId3, ...}

ì˜ˆì‹œ:
filtered:comments:video_001 = {
  "comment_002",   // ë¶€ì ì ˆí•œ ëŒ“ê¸€
  "comment_015",
  "comment_023"
}
```

**ì‚¬ìš© ì´ìœ **:
- FastAPIê°€ í•„í„°ë§ í›„ ë¶€ì ì ˆí•œ ëŒ“ê¸€ IDë§Œ ì €ì¥
- í”„ë¡ íŠ¸ì—ì„œ ëŒ“ê¸€ ì¡°íšŒ ì‹œ í•„í„°ë§ ì—¬ë¶€ ë¹ ë¥´ê²Œ í™•ì¸
- ë©”ëª¨ë¦¬ íš¨ìœ¨ì  (IDë§Œ ì €ì¥)

***

## ì „ì²´ ë°ì´í„° íë¦„

### **Phase 1: ì±„ë„ ë“±ë¡ (Spring)**

```
[1] í”„ë¡ íŠ¸ ìš”ì²­
    POST /api/channels/register
    Body: { channelId: "UCxxxxx" }

[2] Spring Service (@Transactional)
    â”œâ”€ YouTube Data API í˜¸ì¶œ
    â”‚  â”œâ”€ ì „ì²´ ì˜ìƒ ì¡°íšŒ (videos.list)
    â”‚  â””â”€ ê° ì˜ìƒì˜ ëŒ“ê¸€ ì¡°íšŒ (commentThreads.list)
    â”‚
    â”œâ”€ MySQL ì €ì¥
    â”‚  â”œâ”€ ì±„ë„ ì •ë³´ ì €ì¥
    â”‚  â””â”€ ìµœì‹  10ê°œ ì˜ìƒë§Œ ì €ì¥
    â”‚
    â”œâ”€ ì´ë²¤íŠ¸ ë°œí–‰ (ì „ì²´ ë°ì´í„° í¬í•¨)
    â”‚  â””â”€ ChannelSyncedEvent {
    â”‚       channelId,
    â”‚       allVideos: [...],      // ì „ì²´ ì˜ìƒ
    â”‚       allComments: [...]     // ì „ì²´ ëŒ“ê¸€
    â”‚     }
    â”‚
    â””â”€ ì¦‰ì‹œ ì‘ë‹µ ë°˜í™˜

[3] @TransactionalEventListener (AFTER_COMMIT)
    â”œâ”€ Redis ì˜ìƒ ì €ì¥
    â”‚  â””â”€ HSET videos:UCxxxxx video_001 "{YouTube API JSON}"
    â”‚     HSET videos:UCxxxxx video_002 "{...}"
    â”‚     ...
    â”‚
    â””â”€ Redis ëŒ“ê¸€ ì €ì¥
       â””â”€ HSET comments:video_001 comment_001 "{YouTube API JSON}"
          HSET comments:video_001 comment_002 "{...}"
          ...
```

***

### **Phase 2: í•„í„°ë§ ì‘ì—… (FastAPI)**

```
[1] íì—ì„œ ì‘ì—… êº¼ë‚´ê¸°
    BLPOP agent:job-queue
    â†’ {
        "taskId": "task_123",
        "channelId": "UCxxxxx",
        "videoIds": ["video_001", "video_002", ...]
      }

[2] ì˜ìƒë³„ë¡œ ëŒ“ê¸€ ì¡°íšŒ
    for videoId in videoIds:
        # Redisì—ì„œ ëª¨ë“  ëŒ“ê¸€ ì¡°íšŒ
        comments_hash = HGETALL comments:{videoId}
        
        # JSON íŒŒì‹±
        comments = [json.loads(c) for c in comments_hash.values()]

[3] AI í•„í„°ë§
    flagged_ids = []
    for comment in comments:
        text = comment['snippet']['textDisplay']
        
        # LLM ë˜ëŠ” ê·œì¹™ ê¸°ë°˜ í•„í„°ë§
        if is_inappropriate(text):
            flagged_ids.append(comment['id'])

[4] í•„í„°ë§ ê²°ê³¼ ì €ì¥
    if flagged_ids:
        SADD filtered:comments:{videoId} {flagged_ids}

[5] ì‘ì—… ì™„ë£Œ ì½œë°±
    POST http://spring:8080/api/agent/callback
    Body: {
        "taskId": "task_123",
        "channelId": "UCxxxxx",
        "videoId": "video_001",
        "totalCount": 150,
        "flaggedCount": 3,
        "flaggedCommentIds": ["comment_002", ...]
    }
```

***

## Spring êµ¬í˜„ ì½”ë“œ

### **1. Redis Writer (ì˜ìƒ)**

```java
@Component
@RequiredArgsConstructor
public class VideoRedisWriter {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    /**
     * ì±„ë„ì˜ ëª¨ë“  ì˜ìƒì„ Redis Hashì— ì €ì¥
     * YouTube API ì‘ë‹µ ê·¸ëŒ€ë¡œ ì €ì¥
     */
    public void saveVideos(String channelId, List<YouTubeVideo> videos) {
        String redisKey = "videos:" + channelId;
        
        Map<String, String> videoMap = new HashMap<>();
        for (YouTubeVideo video : videos) {
            try {
                // YouTube API ì‘ë‹µì„ JSONìœ¼ë¡œ ì§ë ¬í™”
                String videoJson = objectMapper.writeValueAsString(video);
                videoMap.put(video.getId(), videoJson);
            } catch (JsonProcessingException e) {
                log.error("ì˜ìƒ ì§ë ¬í™” ì‹¤íŒ¨: videoId={}", video.getId(), e);
            }
        }
        
        // ë°°ì¹˜ë¡œ í•œ ë²ˆì— ì €ì¥
        redisTemplate.opsForHash().putAll(redisKey, videoMap);
        
        // TTL ì„¤ì • (7ì¼)
        redisTemplate.expire(redisKey, Duration.ofDays(7));
        
        log.info("ì˜ìƒ ì €ì¥ ì™„ë£Œ: channelId={}, count={}", channelId, videos.size());
    }
    
    /**
     * íŠ¹ì • ì˜ìƒ ì¡°íšŒ
     */
    public YouTubeVideo getVideo(String channelId, String videoId) {
        String redisKey = "videos:" + channelId;
        Object videoJson = redisTemplate.opsForHash().get(redisKey, videoId);
        
        if (videoJson == null) {
            return null;
        }
        
        try {
            return objectMapper.readValue(videoJson.toString(), YouTubeVideo.class);
        } catch (JsonProcessingException e) {
            log.error("ì˜ìƒ ì—­ì§ë ¬í™” ì‹¤íŒ¨: videoId={}", videoId, e);
            return null;
        }
    }
    
    /**
     * ì±„ë„ì˜ ëª¨ë“  ì˜ìƒ ì¡°íšŒ
     */
    public List<YouTubeVideo> getAllVideos(String channelId) {
        String redisKey = "videos:" + channelId;
        Map<Object, Object> videosMap = redisTemplate.opsForHash().entries(redisKey);
        
        return videosMap.values().stream()
            .map(json -> {
                try {
                    return objectMapper.readValue(json.toString(), YouTubeVideo.class);
                } catch (JsonProcessingException e) {
                    log.error("ì˜ìƒ ì—­ì§ë ¬í™” ì‹¤íŒ¨", e);
                    return null;
                }
            })
            .filter(Objects::nonNull)
            .toList();
    }
}
```

***

### **2. Redis Writer (ëŒ“ê¸€)**

```java
@Component
@RequiredArgsConstructor
public class CommentRedisWriter {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    /**
     * ì˜ìƒì˜ ëª¨ë“  ëŒ“ê¸€ì„ Redis Hashì— ì €ì¥
     * YouTube API ì‘ë‹µ ê·¸ëŒ€ë¡œ ì €ì¥
     */
    public void saveComments(String videoId, List<YouTubeComment> comments) {
        String redisKey = "comments:" + videoId;
        
        Map<String, String> commentMap = new HashMap<>();
        for (YouTubeComment comment : comments) {
            try {
                // YouTube API ì‘ë‹µì„ JSONìœ¼ë¡œ ì§ë ¬í™”
                String commentJson = objectMapper.writeValueAsString(comment);
                commentMap.put(comment.getId(), commentJson);
            } catch (JsonProcessingException e) {
                log.error("ëŒ“ê¸€ ì§ë ¬í™” ì‹¤íŒ¨: commentId={}", comment.getId(), e);
            }
        }
        
        // ë°°ì¹˜ë¡œ í•œ ë²ˆì— ì €ì¥
        redisTemplate.opsForHash().putAll(redisKey, commentMap);
        
        // TTL ì„¤ì • (7ì¼)
        redisTemplate.expire(redisKey, Duration.ofDays(7));
        
        log.info("ëŒ“ê¸€ ì €ì¥ ì™„ë£Œ: videoId={}, count={}", videoId, comments.size());
    }
    
    /**
     * ì˜ìƒì˜ ëª¨ë“  ëŒ“ê¸€ ì¡°íšŒ
     */
    public List<YouTubeComment> getAllComments(String videoId) {
        String redisKey = "comments:" + videoId;
        Map<Object, Object> commentsMap = redisTemplate.opsForHash().entries(redisKey);
        
        return commentsMap.values().stream()
            .map(json -> {
                try {
                    return objectMapper.readValue(json.toString(), YouTubeComment.class);
                } catch (JsonProcessingException e) {
                    log.error("ëŒ“ê¸€ ì—­ì§ë ¬í™” ì‹¤íŒ¨", e);
                    return null;
                }
            })
            .filter(Objects::nonNull)
            .toList();
    }
    
    /**
     * í•„í„°ë§ëœ ëŒ“ê¸€ ID ì¡°íšŒ
     */
    public Set<String> getFilteredCommentIds(String videoId) {
        String redisKey = "filtered:comments:" + videoId;
        Set<Object> members = redisTemplate.opsForSet().members(redisKey);
        
        return members.stream()
            .map(Object::toString)
            .collect(Collectors.toSet());
    }
}
```

***

### **3. DTO (YouTube API í˜•ì‹)**

```java
/**
 * YouTube Data API - Video Resource
 * https://developers.google.com/youtube/v3/docs/videos#resource
 */
@Data
public class YouTubeVideo {
    private String kind;  // "youtube#video"
    private String id;
    private VideoSnippet snippet;
    private VideoStatistics statistics;
    private VideoContentDetails contentDetails;
    
    @Data
    public static class VideoSnippet {
        private String publishedAt;
        private String channelId;
        private String title;
        private String description;
        private Map<String, Thumbnail> thumbnails;
        private String channelTitle;
        private List<String> tags;
        private String categoryId;
    }
    
    @Data
    public static class VideoStatistics {
        private String viewCount;
        private String likeCount;
        private String commentCount;
    }
    
    @Data
    public static class VideoContentDetails {
        private String duration;  // ISO 8601 (PT10M30S)
        private String dimension;
        private String definition;
    }
    
    @Data
    public static class Thumbnail {
        private String url;
        private Integer width;
        private Integer height;
    }
}

/**
 * YouTube Data API - Comment Resource
 * https://developers.google.com/youtube/v3/docs/comments#resource
 */
@Data
public class YouTubeComment {
    private String kind;  // "youtube#comment"
    private String id;
    private CommentSnippet snippet;
    
    @Data
    public static class CommentSnippet {
        private String authorDisplayName;
        private String authorProfileImageUrl;
        private String authorChannelUrl;
        private String textDisplay;
        private String textOriginal;
        private Integer likeCount;
        private String publishedAt;
        private String updatedAt;
    }
}
```

***

## í ë°ì´í„° êµ¬ì¡°

```json
{
  "taskId": "uuid",
  "channelId": "UCxxxxx",
  "videoIds": ["video_001", "video_002", "video_003"],
  "createdAt": "2025-11-12T09:00:00Z"
}
```

**FastAPIê°€ ë°›ì•„ì„œ**:
1. `channelId` ë¬´ì‹œ (ì‚¬ìš© ì•ˆ í•¨)
2. `videoIds` ê°ê°ì— ëŒ€í•´:
   - `HGETALL comments:{videoId}` ì‹¤í–‰
   - ëŒ“ê¸€ í•„í„°ë§
   - `SADD filtered:comments:{videoId}` ì €ì¥

***

## í•µì‹¬ ì •ë¦¬

| í•­ëª© | êµ¬ì¡° | ì˜ˆì‹œ |
|------|------|------|
| **ì˜ìƒ** | `videos:{channelId}` (Hash) | `videos:UCxxxxx` |
| **ëŒ“ê¸€** | `comments:{videoId}` (Hash) | `comments:video_001` |
| **í•„í„°ë§ ê²°ê³¼** | `filtered:comments:{videoId}` (Set) | `filtered:comments:video_001` |
| **í** | `agent:job-queue` (List) | `{taskId, channelId, videoIds}` |

**ë°ì´í„° í˜•ì‹**: YouTube Data API ì‘ë‹µ **ê·¸ëŒ€ë¡œ** (JSON)

**ì´ì œ ì™„ë²½í•©ë‹ˆë‹¤!** í•„ìš”í•œ ëª¨ë“  ì •ë³´ê°€ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ğŸ¯

ë„¤, ì™„ì „íˆ ê°€ëŠ¥í•©ë‹ˆë‹¤! **Redis ZSet (Sorted Set)**ì„ ì¶”ê°€ë¡œ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.

---

## í•´ê²° ë°©ë²•: Hash + ZSet ì¡°í•©

### **í˜„ì¬ êµ¬ì¡° (Hashë§Œ ì‚¬ìš©)**
```
videos:UCxxxxx (Hash)
â”œâ”€ video_001: {JSON}
â”œâ”€ video_002: {JSON}
â””â”€ video_003: {JSON}

ë¬¸ì œ: ì •ë ¬ ë¶ˆê°€! (HashëŠ” ìˆœì„œ ì—†ìŒ)
```

### **ê°œì„ ëœ êµ¬ì¡° (Hash + ZSet)**
```
[1] ìƒì„¸ ì •ë³´ (Hash)
videos:UCxxxxx (Hash)
â”œâ”€ video_001: {JSON}
â”œâ”€ video_002: {JSON}
â””â”€ video_003: {JSON}

[2] ì¸ê¸°ìˆœ ì •ë ¬ (ZSet)
videos:sorted:popular:UCxxxxx (ZSet)
â”œâ”€ score: 1234567 (ì¡°íšŒìˆ˜) â†’ member: video_001
â”œâ”€ score: 987654 (ì¡°íšŒìˆ˜)  â†’ member: video_002
â””â”€ score: 456789 (ì¡°íšŒìˆ˜)  â†’ member: video_003

[3] ìµœì‹ ìˆœ ì •ë ¬ (ZSet)
videos:sorted:recent:UCxxxxx (ZSet)
â”œâ”€ score: 1731398400 (timestamp) â†’ member: video_001
â”œâ”€ score: 1731312000 (timestamp) â†’ member: video_002
â””â”€ score: 1731225600 (timestamp) â†’ member: video_003
```

**í•µì‹¬**: 
- Hashì—ëŠ” **ì „ì²´ ë°ì´í„°** ì €ì¥
- ZSetì—ëŠ” **ì •ë ¬ìš© ì ìˆ˜ + IDë§Œ** ì €ì¥

***

## Redis ë°ì´í„° êµ¬ì¡° (ìµœì¢…)

### **1. ì˜ìƒ ë°ì´í„°**

```
# ìƒì„¸ ì •ë³´ (ë³€ê²½ ì—†ìŒ)
Key: videos:{channelId}
Type: Hash
Field: videoId
Value: YouTube API JSON

# ì¸ê¸°ìˆœ ì •ë ¬ (ì¶”ê°€!)
Key: videos:sorted:popular:{channelId}
Type: ZSet
Score: viewCount (ì¡°íšŒìˆ˜)
Member: videoId

# ìµœì‹ ìˆœ ì •ë ¬ (ì¶”ê°€!)
Key: videos:sorted:recent:{channelId}
Type: ZSet
Score: publishedAt (Unix timestamp)
Member: videoId

# ì¢‹ì•„ìš”ìˆœ ì •ë ¬ (ì¶”ê°€!)
Key: videos:sorted:likes:{channelId}
Type: ZSet
Score: likeCount
Member: videoId
```

### **2. ëŒ“ê¸€ ë°ì´í„°**

```
# ìƒì„¸ ì •ë³´ (ë³€ê²½ ì—†ìŒ)
Key: comments:{videoId}
Type: Hash
Field: commentId
Value: YouTube API JSON

# ìµœì‹ ìˆœ ì •ë ¬ (ì¶”ê°€!)
Key: comments:sorted:recent:{videoId}
Type: ZSet
Score: publishedAt (Unix timestamp)
Member: commentId

# ì¢‹ì•„ìš”ìˆœ ì •ë ¬ (ì¶”ê°€!)
Key: comments:sorted:likes:{videoId}
Type: ZSet
Score: likeCount
Member: commentId
```

***

## Spring êµ¬í˜„ ì½”ë“œ

### **VideoRedisWriter (ê°œì„ )**

```java
@Component
@RequiredArgsConstructor
public class VideoRedisWriter {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    /**
     * ì˜ìƒ ì €ì¥ (Hash + ZSet)
     */
    public void saveVideos(String channelId, List<YouTubeVideo> videos) {
        String hashKey = "videos:" + channelId;
        String popularKey = "videos:sorted:popular:" + channelId;
        String recentKey = "videos:sorted:recent:" + channelId;
        String likesKey = "videos:sorted:likes:" + channelId;
        
        // Pipeline ì‚¬ìš© (ì„±ëŠ¥ ìµœì í™”)
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            for (YouTubeVideo video : videos) {
                try {
                    String videoId = video.getId();
                    String videoJson = objectMapper.writeValueAsString(video);
                    
                    // 1. Hashì— ìƒì„¸ ì •ë³´ ì €ì¥
                    connection.hashCommands().hSet(
                        hashKey.getBytes(),
                        videoId.getBytes(),
                        videoJson.getBytes()
                    );
                    
                    // 2. ì¸ê¸°ìˆœ ZSet (ì¡°íšŒìˆ˜)
                    long viewCount = Long.parseLong(
                        video.getStatistics().getViewCount()
                    );
                    connection.zSetCommands().zAdd(
                        popularKey.getBytes(),
                        viewCount,
                        videoId.getBytes()
                    );
                    
                    // 3. ìµœì‹ ìˆœ ZSet (ê²Œì‹œì¼)
                    long publishedAt = parseTimestamp(
                        video.getSnippet().getPublishedAt()
                    );
                    connection.zSetCommands().zAdd(
                        recentKey.getBytes(),
                        publishedAt,
                        videoId.getBytes()
                    );
                    
                    // 4. ì¢‹ì•„ìš”ìˆœ ZSet
                    long likeCount = Long.parseLong(
                        video.getStatistics().getLikeCount()
                    );
                    connection.zSetCommands().zAdd(
                        likesKey.getBytes(),
                        likeCount,
                        videoId.getBytes()
                    );
                    
                } catch (JsonProcessingException e) {
                    log.error("ì˜ìƒ ì§ë ¬í™” ì‹¤íŒ¨: videoId={}", video.getId(), e);
                }
            }
            return null;
        });
        
        // TTL ì„¤ì •
        redisTemplate.expire(hashKey, Duration.ofDays(7));
        redisTemplate.expire(popularKey, Duration.ofDays(7));
        redisTemplate.expire(recentKey, Duration.ofDays(7));
        redisTemplate.expire(likesKey, Duration.ofDays(7));
        
        log.info("ì˜ìƒ ì €ì¥ ì™„ë£Œ: channelId={}, count={}", channelId, videos.size());
    }
    
    /**
     * ì˜ìƒ ì¡°íšŒ (ì •ë ¬ ì˜µì…˜ ì§€ì›)
     * 
     * @param sortBy "popular", "recent", "likes"
     */
    public List<YouTubeVideo> getVideosSorted(
            String channelId, 
            String sortBy, 
            int limit) {
        
        // 1. ZSetì—ì„œ ì •ë ¬ëœ videoId ëª©ë¡ ì¡°íšŒ
        String sortKey = switch (sortBy) {
            case "popular" -> "videos:sorted:popular:" + channelId;
            case "recent" -> "videos:sorted:recent:" + channelId;
            case "likes" -> "videos:sorted:likes:" + channelId;
            default -> "videos:sorted:popular:" + channelId;
        };
        
        // ZREVRANGE: ë†’ì€ ì ìˆ˜ë¶€í„° (ë‚´ë¦¼ì°¨ìˆœ)
        Set<Object> videoIds = redisTemplate.opsForZSet()
            .reverseRange(sortKey, 0, limit - 1);
        
        if (videoIds == null || videoIds.isEmpty()) {
            return List.of();
        }
        
        // 2. Hashì—ì„œ ìƒì„¸ ì •ë³´ ì¡°íšŒ
        String hashKey = "videos:" + channelId;
        List<Object> videoJsons = redisTemplate.opsForHash()
            .multiGet(hashKey, videoIds);
        
        // 3. JSON â†’ Object ë³€í™˜
        return videoJsons.stream()
            .filter(Objects::nonNull)
            .map(json -> {
                try {
                    return objectMapper.readValue(
                        json.toString(), 
                        YouTubeVideo.class
                    );
                } catch (JsonProcessingException e) {
                    log.error("ì˜ìƒ ì—­ì§ë ¬í™” ì‹¤íŒ¨", e);
                    return null;
                }
            })
            .filter(Objects::nonNull)
            .toList();
    }
    
    /**
     * ISO 8601 â†’ Unix Timestamp
     */
    private long parseTimestamp(String iso8601) {
        return Instant.parse(iso8601).getEpochSecond();
    }
}
```

***

### **CommentRedisWriter (ê°œì„ )**

```java
@Component
@RequiredArgsConstructor
public class CommentRedisWriter {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final ObjectMapper objectMapper;
    
    /**
     * ëŒ“ê¸€ ì €ì¥ (Hash + ZSet)
     */
    public void saveComments(String videoId, List<YouTubeComment> comments) {
        String hashKey = "comments:" + videoId;
        String recentKey = "comments:sorted:recent:" + videoId;
        String likesKey = "comments:sorted:likes:" + videoId;
        
        // Pipeline ì‚¬ìš©
        redisTemplate.executePipelined((RedisCallback<Object>) connection -> {
            for (YouTubeComment comment : comments) {
                try {
                    String commentId = comment.getId();
                    String commentJson = objectMapper.writeValueAsString(comment);
                    
                    // 1. Hashì— ìƒì„¸ ì •ë³´ ì €ì¥
                    connection.hashCommands().hSet(
                        hashKey.getBytes(),
                        commentId.getBytes(),
                        commentJson.getBytes()
                    );
                    
                    // 2. ìµœì‹ ìˆœ ZSet
                    long publishedAt = parseTimestamp(
                        comment.getSnippet().getPublishedAt()
                    );
                    connection.zSetCommands().zAdd(
                        recentKey.getBytes(),
                        publishedAt,
                        commentId.getBytes()
                    );
                    
                    // 3. ì¢‹ì•„ìš”ìˆœ ZSet
                    int likeCount = comment.getSnippet().getLikeCount();
                    connection.zSetCommands().zAdd(
                        likesKey.getBytes(),
                        likeCount,
                        commentId.getBytes()
                    );
                    
                } catch (JsonProcessingException e) {
                    log.error("ëŒ“ê¸€ ì§ë ¬í™” ì‹¤íŒ¨: commentId={}", comment.getId(), e);
                }
            }
            return null;
        });
        
        // TTL ì„¤ì •
        redisTemplate.expire(hashKey, Duration.ofDays(7));
        redisTemplate.expire(recentKey, Duration.ofDays(7));
        redisTemplate.expire(likesKey, Duration.ofDays(7));
    }
    
    /**
     * ëŒ“ê¸€ ì¡°íšŒ (ì •ë ¬ ì˜µì…˜ ì§€ì›)
     * 
     * @param sortBy "recent", "likes"
     */
    public List<YouTubeComment> getCommentsSorted(
            String videoId, 
            String sortBy, 
            int offset, 
            int limit) {
        
        // 1. ZSetì—ì„œ ì •ë ¬ëœ commentId ëª©ë¡ ì¡°íšŒ
        String sortKey = sortBy.equals("likes") 
            ? "comments:sorted:likes:" + videoId
            : "comments:sorted:recent:" + videoId;
        
        Set<Object> commentIds = redisTemplate.opsForZSet()
            .reverseRange(sortKey, offset, offset + limit - 1);
        
        if (commentIds == null || commentIds.isEmpty()) {
            return List.of();
        }
        
        // 2. Hashì—ì„œ ìƒì„¸ ì •ë³´ ì¡°íšŒ
        String hashKey = "comments:" + videoId;
        List<Object> commentJsons = redisTemplate.opsForHash()
            .multiGet(hashKey, commentIds);
        
        // 3. JSON â†’ Object ë³€í™˜
        return commentJsons.stream()
            .filter(Objects::nonNull)
            .map(json -> {
                try {
                    return objectMapper.readValue(
                        json.toString(), 
                        YouTubeComment.class
                    );
                } catch (JsonProcessingException e) {
                    return null;
                }
            })
            .filter(Objects::nonNull)
            .toList();
    }
    
    private long parseTimestamp(String iso8601) {
        return Instant.parse(iso8601).getEpochSecond();
    }
}
```

***

## Controller ì˜ˆì‹œ

```java
@RestController
@RequestMapping("/api/videos")
@RequiredArgsConstructor
public class VideoController {
    
    private final VideoRedisWriter videoRedisWriter;
    
    /**
     * ì˜ìƒ ëª©ë¡ ì¡°íšŒ (ì •ë ¬ ì§€ì›)
     * GET /api/videos?channelId=UCxxxxx&sortBy=popular&limit=20
     */
    @GetMapping
    public ResponseEntity<List<YouTubeVideo>> getVideos(
            @RequestParam String channelId,
            @RequestParam(defaultValue = "popular") String sortBy,
            @RequestParam(defaultValue = "20") int limit) {
        
        List<YouTubeVideo> videos = videoRedisWriter.getVideosSorted(
            channelId, 
            sortBy, 
            limit
        );
        
        return ResponseEntity.ok(videos);
    }
}

@RestController
@RequestMapping("/api/comments")
@RequiredArgsConstructor
public class CommentController {
    
    private final CommentRedisWriter commentRedisWriter;
    
    /**
     * ëŒ“ê¸€ ëª©ë¡ ì¡°íšŒ (ì •ë ¬ + í˜ì´ì§•)
     * GET /api/comments?videoId=video_001&sortBy=recent&page=1&size=20
     */
    @GetMapping
    public ResponseEntity<List<YouTubeComment>> getComments(
            @RequestParam String videoId,
            @RequestParam(defaultValue = "recent") String sortBy,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        int offset = page * size;
        
        List<YouTubeComment> comments = commentRedisWriter.getCommentsSorted(
            videoId, 
            sortBy, 
            offset, 
            size
        );
        
        return ResponseEntity.ok(comments);
    }
}
```

***

## ì‚¬ìš© ì˜ˆì‹œ

### **ì˜ìƒ ì¡°íšŒ**

```bash
# ì¸ê¸°ìˆœ (ì¡°íšŒìˆ˜ ë†’ì€ ìˆœ)
GET /api/videos?channelId=UCxxxxx&sortBy=popular&limit=10

# ìµœì‹ ìˆœ (ìµœê·¼ ì—…ë¡œë“œ ìˆœ)
GET /api/videos?channelId=UCxxxxx&sortBy=recent&limit=10

# ì¢‹ì•„ìš”ìˆœ
GET /api/videos?channelId=UCxxxxx&sortBy=likes&limit=10
```

### **ëŒ“ê¸€ ì¡°íšŒ**

```bash
# ìµœì‹ ìˆœ (ì²« í˜ì´ì§€)
GET /api/comments?videoId=video_001&sortBy=recent&page=0&size=20

# ìµœì‹ ìˆœ (ë‘ ë²ˆì§¸ í˜ì´ì§€)
GET /api/comments?videoId=video_001&sortBy=recent&page=1&size=20

# ì¢‹ì•„ìš”ìˆœ
GET /api/comments?videoId=video_001&sortBy=likes&page=0&size=20
```

***

## ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰

### **ì˜ˆì‹œ: ì±„ë„ì— ì˜ìƒ 100ê°œ**

**Hashë§Œ ì‚¬ìš©**:
```
videos:UCxxxxx (Hash)
â””â”€ 100ê°œ ì˜ìƒ Ã— 2KB = 200KB
```

**Hash + ZSet ì‚¬ìš©**:
```
videos:UCxxxxx (Hash)
â””â”€ 100ê°œ ì˜ìƒ Ã— 2KB = 200KB

videos:sorted:popular:UCxxxxx (ZSet)
â””â”€ 100ê°œ videoId Ã— 20 bytes = 2KB

videos:sorted:recent:UCxxxxx (ZSet)
â””â”€ 100ê°œ videoId Ã— 20 bytes = 2KB

videos:sorted:likes:UCxxxxx (ZSet)
â””â”€ 100ê°œ videoId Ã— 20 bytes = 2KB

ì´: 206KB (Hash ëŒ€ë¹„ +3% ì¦ê°€)
```

**ê²°ë¡ **: ë©”ëª¨ë¦¬ ì¦ê°€ëŠ” **ë¯¸ë¯¸**í•˜ì§€ë§Œ, ì •ë ¬ ì„±ëŠ¥ì€ **ê·¹ì ìœ¼ë¡œ í–¥ìƒ**!

***

## ì„±ëŠ¥ ë¹„êµ

| ì •ë ¬ ë°©ì‹ | Hashë§Œ | Hash + ZSet |
|----------|--------|-------------|
| **ì¡°íšŒ ì‹œê°„** | O(N log N) | O(log N) |
| **100ê°œ ì •ë ¬** | ~10ms | ~0.1ms |
| **1000ê°œ ì •ë ¬** | ~100ms | ~0.2ms |
| **ë©”ëª¨ë¦¬** | 200KB | 206KB |

**ê²°ë¡ **: ZSet ì¶”ê°€ë¡œ **100ë°° ë¹ ë¥¸ ì •ë ¬** ê°€ëŠ¥! âœ…

***

## ìµœì¢… Redis êµ¬ì¡°

```
ì±„ë„ UCxxxxxì˜ ë°ì´í„°:

[ì˜ìƒ]
videos:UCxxxxx (Hash)                          - ìƒì„¸ ì •ë³´
videos:sorted:popular:UCxxxxx (ZSet)           - ì¸ê¸°ìˆœ
videos:sorted:recent:UCxxxxx (ZSet)            - ìµœì‹ ìˆœ
videos:sorted:likes:UCxxxxx (ZSet)             - ì¢‹ì•„ìš”ìˆœ

[ëŒ“ê¸€ - video_001]
comments:video_001 (Hash)                      - ìƒì„¸ ì •ë³´
comments:sorted:recent:video_001 (ZSet)        - ìµœì‹ ìˆœ
comments:sorted:likes:video_001 (ZSet)         - ì¢‹ì•„ìš”ìˆœ
filtered:comments:video_001 (Set)              - í•„í„°ë§ ê²°ê³¼

[ëŒ“ê¸€ - video_002]
comments:video_002 (Hash)
comments:sorted:recent:video_002 (ZSet)
comments:sorted:likes:video_002 (ZSet)
filtered:comments:video_002 (Set)
...
```

**ì™„ë²½í•˜ê²Œ ì •ë ¬ ê°€ëŠ¥í•©ë‹ˆë‹¤!** ğŸ¯
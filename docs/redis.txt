============================================================
Medi Backend - Redis 구조 및 사용 가이드 (최신화)
============================================================

본 문서는 Medi Backend 프로젝트에서 사용하는 Redis 구조와 사용법을 설명합니다.

------------------------------------------------------------
1. Redis 설정
------------------------------------------------------------

● 연결 정보
- Host: localhost (기본값)
- Port: 6379 (기본값)
- 설정 파일: application.yml
  ```yaml
  spring:
    data:
      redis:
        host: localhost
        port: 6379
  ```

● Redis 데이터베이스 분리
- DB 0: YouTube 데이터 저장 (채널, 영상, 댓글, 자막)
- DB 1: 작업 큐 (Profiling, Filtering 작업)

● Redis 템플릿
- `StringRedisTemplate` (Primary): DB 0 사용, 문자열 기반
- `RedisTemplate<String, Object>`: DB 0 사용, JSON 직렬화
- `redisQueueTemplate`: DB 1 사용, 작업 큐 전용

------------------------------------------------------------
2. Redis 키 구조 (DB 0)
------------------------------------------------------------

● 채널별 Top 20 비디오 ID Set
- Key: `channel:{channel_id}:top20_video_ids`
- Type: Set
- Value: 비디오 ID 목록 (Set)
- TTL: 없음 (수동 삭제)
- 설명: 각 채널의 조회수 상위 20개 비디오 ID 저장

● 비디오 메타데이터
- Key: `video:{video_id}:meta:json`
- Type: String (JSON)
- Value: JSON 문자열
  ```json
  {
    "channel_id": "UC...",
    "video_id": "dQw4w9WgXcQ",
    "video_title": "Video Title",
    "video_tags": ["tag1", "tag2"],
    "view_count": 12345,
    "like_count": 567,
    "comment_count": 89,
    "published_at": "2025-11-10T17:30:00"
  }
  ```
- TTL: 3일
- 설명: 비디오의 메타데이터 저장

● 비디오 댓글 (초기 동기화)
- Key: `video:{video_id}:comments:init`
- Type: String (JSON Array)
- Value: JSON 배열 문자열
  ```json
  [
    {
      "comment_id": "comment123",
      "author": "User Name",
      "text": "Comment text",
      "like_count": 10,
      "published_at": "2025-11-10T18:00:00",
      ...
    },
    ...
  ]
  ```
- TTL: 없음 (수동 삭제)
- 설명: 채널 프로파일링용 초기 댓글 데이터 (상위 20개 영상, 각 100개 댓글)

● 비디오 댓글 (증분 동기화)
- Key: `video:{video_id}:comments`
- Type: Hash
- Field: `{comment_id}`
- Value: JSON 문자열 (댓글 전체 메타데이터)
  ```json
  {
    "comment_id": "comment123",
    "author": "User Name",
    "text": "Comment text",
    "like_count": 10,
    "published_at": "2025-11-10T18:00:00",
    "parent_id": null,
    "reply_count": 0,
    ...
  }
  ```
- TTL: 없음 (수동 삭제)
- 설명: 원본 댓글 데이터 (절대 수정 금지), 증분 동기화 시 사용

● 비디오 댓글 분류 결과 (FastAPI Agent가 저장)
- Key: `video:{video_id}:classification`
- Type: Hash
- Field: `{comment_id}`
- Value: JSON 문자열 (분류 결과)
  ```json
  {
    "comment_id": "comment123",
    "harmfulness_level": "HIGH",
    "detected_category": "SPAM",
    "detection_source": "AI_MODEL",
    "confidence": 0.95,
    "status": "HIDE",
    ...
  }
  ```
- TTL: 없음 (수동 삭제)
- 설명: AI Agent가 분석한 댓글 분류 결과

● 비디오 자막
- Key: `video:{video_id}:transcript:json`
- Type: String (JSON)
- Value: JSON 문자열
  ```json
  {
    "video_id": "dQw4w9WgXcQ",
    "video_title": "Video Title",
    "transcript_text": "Full transcript text...",
    "language": "ko",
    "source": "youtube_api" | "yt_dlp",
    "extracted_at": "2025-11-10T18:00:00"
  }
  ```
- TTL: 3일
- 설명: 비디오 자막 텍스트 (채널 성격 파악용)

------------------------------------------------------------
3. Redis 작업 큐 구조 (DB 1)
------------------------------------------------------------

● Profiling 작업 큐
- Key: `profiling_agent:tasks:queue`
- Type: List (FIFO)
- Value: JSON 문자열 (작업 정보)
  ```json
  {
    "channelId": "UC...",
    "type": "profiling",
    "videoIds": ["vid1", "vid2", ...]  // optional
  }
  ```
- 설명: 채널 프로파일링 작업 큐 (AI Agent가 소비)

● Filtering 작업 큐
- Key: `filtering_agent:tasks:queue`
- Type: List (FIFO)
- Value: JSON 문자열 (작업 정보)
  ```json
  {
    "channelId": "UC...",
    "type": "filtering",
    "videoIds": ["vid1", "vid2", ...]  // required
  }
  ```
- 설명: 댓글 필터링 작업 큐 (AI Agent가 소비)

------------------------------------------------------------
4. Redis 동기화 프로세스
------------------------------------------------------------

● 초기 동기화 (Full Sync)
1. 사용자의 채널 목록을 YouTube API로 조회
2. 각 채널의 조회수 상위 20개 비디오 ID를 Redis Set에 저장
   - Key: `channel:{channel_id}:top20_video_ids`
3. 각 비디오의 메타데이터를 Redis에 저장
   - Key: `video:{video_id}:meta:json`
4. 각 비디오의 댓글 100개를 Redis에 저장 (초기 동기화용)
   - Key: `video:{video_id}:comments:init`
5. 각 비디오의 자막을 Redis에 저장 (채널 성격 파악용)
   - Key: `video:{video_id}:transcript:json`
6. 작업 큐에 Profiling 작업 추가
   - Queue: `profiling_agent:tasks:queue`

● 증분 동기화 (Incremental Sync)
1. 이전 동기화에서 저장된 비디오 ID 목록 사용
2. 새로운 비디오가 있는지 확인
3. 새 비디오의 메타데이터와 댓글을 Redis에 저장
   - 메타데이터: `video:{video_id}:meta:json`
   - 댓글: `video:{video_id}:comments` (Hash 타입)
4. 작업 큐에 Filtering 작업 추가
   - Queue: `filtering_agent:tasks:queue`

------------------------------------------------------------
5. Redis 서비스 API
------------------------------------------------------------

● YoutubeRedisSyncService
- `syncToRedis(Integer userId)`: 초기 동기화
- `syncIncrementalToRedis(Integer userId, List<String> videoIds)`: 증분 동기화

● RedisQueueService
- `enqueueProfiling(String channelId, List<String> videoIds)`: Profiling 작업 추가
- `enqueueFiltering(String channelId, List<String> videoIds)`: Filtering 작업 추가
- `getQueueStats()`: 큐 상태 조회
- `clearQueue(String queueType)`: 큐 비우기

● YoutubeTranscriptService
- `saveTranscriptsToRedis(List<String> videoIds, YouTube yt)`: 자막 저장
- `getTranscriptFromRedis(String videoId)`: 자막 조회

------------------------------------------------------------
6. Redis 사용 예시
------------------------------------------------------------

● 초기 동기화 실행
```bash
POST /api/youtube/channels/redis/sync
```

● 증분 동기화 실행
```bash
POST /api/test/youtube/redis/sync/incremental
Body: { "userId": 1 }
```

● 큐 상태 조회
```bash
GET /api/test/queue/stats
Response:
{
  "success": true,
  "stats": {
    "profiling_queue_length": 5,
    "filtering_queue_length": 10
  }
}
```

● 큐 비우기
```bash
DELETE /api/test/queue/clear?type=all
```

● Profiling 작업 추가
```bash
POST /api/test/queue/profiling
Body: {
  "channelId": "UC...",
  "videoIds": ["vid1", "vid2"]  // optional
}
```

● Filtering 작업 추가
```bash
POST /api/test/queue/filtering
Body: {
  "channelId": "UC...",
  "videoIds": ["vid1", "vid2"]  // required
}
```

------------------------------------------------------------
7. Redis 데이터 접근 패턴
------------------------------------------------------------

● 채널의 Top 20 비디오 ID 조회
```java
Set<String> videoIds = stringRedisTemplate.opsForSet()
    .members("channel:" + channelId + ":top20_video_ids");
```

● 비디오 메타데이터 조회
```java
String metaJson = stringRedisTemplate.opsForValue()
    .get("video:" + videoId + ":meta:json");
```

● 비디오 댓글 조회 (초기 동기화)
```java
String commentsJson = stringRedisTemplate.opsForValue()
    .get("video:" + videoId + ":comments:init");
```

● 비디오 댓글 조회 (증분 동기화)
```java
Map<Object, Object> comments = stringRedisTemplate.opsForHash()
    .entries("video:" + videoId + ":comments");
```

● 비디오 분류 결과 조회
```java
Map<Object, Object> classifications = stringRedisTemplate.opsForHash()
    .entries("video:" + videoId + ":classification");
```

● 비디오 자막 조회
```java
String transcriptJson = stringRedisTemplate.opsForValue()
    .get("video:" + videoId + ":transcript:json");
```

● 작업 큐에서 작업 가져오기 (AI Agent용)
```java
String taskJson = redisQueueTemplate.opsForList()
    .rightPop("profiling_agent:tasks:queue");
```

------------------------------------------------------------
8. Redis 주의사항
------------------------------------------------------------

1. **데이터베이스 분리**
   - DB 0: YouTube 데이터 (채널, 영상, 댓글, 자막)
   - DB 1: 작업 큐 (Profiling, Filtering)

2. **TTL 설정**
   - 비디오 메타데이터: 3일
   - 비디오 자막: 3일
   - 댓글 데이터: TTL 없음 (수동 삭제)

3. **댓글 데이터 구조**
   - 초기 동기화: `video:{video_id}:comments:init` (String, JSON Array)
   - 증분 동기화: `video:{video_id}:comments` (Hash)
   - 분류 결과: `video:{video_id}:classification` (Hash, AI Agent가 저장)

4. **작업 큐 사용**
   - Profiling 작업: `profiling_agent:tasks:queue`
   - Filtering 작업: `filtering_agent:tasks:queue`
   - 큐는 FIFO 방식으로 동작 (leftPush로 추가, rightPop으로 소비)

5. **동기화 모드**
   - 초기 동기화: 모든 채널의 상위 20개 영상 동기화
   - 증분 동기화: 새로 업로드된 영상만 동기화

6. **에러 처리**
   - YouTube API 쿼터 초과 시 기존 DB 데이터 반환
   - OAuth 토큰 만료 시 재연결 필요
   - Redis 연결 실패 시 로그 기록 및 예외 처리

------------------------------------------------------------
9. Redis 모니터링
------------------------------------------------------------

● 큐 상태 확인
```bash
GET /api/test/queue/stats
```

● Redis CLI로 직접 확인
```bash
# DB 0 접속
redis-cli
SELECT 0

# 채널의 Top 20 비디오 ID 조회
SMEMBERS channel:UC...:top20_video_ids

# 비디오 메타데이터 조회
GET video:dQw4w9WgXcQ:meta:json

# 비디오 댓글 조회 (초기 동기화)
GET video:dQw4w9WgXcQ:comments:init

# 비디오 댓글 조회 (증분 동기화)
HGETALL video:dQw4w9WgXcQ:comments

# 비디오 분류 결과 조회
HGETALL video:dQw4w9WgXcQ:classification

# 비디오 자막 조회
GET video:dQw4w9WgXcQ:transcript:json

# DB 1 접속 (작업 큐)
SELECT 1

# Profiling 큐 길이 확인
LLEN profiling_agent:tasks:queue

# Filtering 큐 길이 확인
LLEN filtering_agent:tasks:queue

# 큐에서 작업 가져오기 (소비)
RPOP profiling_agent:tasks:queue
```

------------------------------------------------------------
10. Redis 성능 최적화
------------------------------------------------------------

1. **배치 작업 사용**
   - 여러 비디오의 메타데이터를 한 번에 저장
   - Pipeline 사용으로 네트워크 왕복 횟수 감소

2. **TTL 관리**
   - 자주 사용되지 않는 데이터는 TTL 설정
   - 중요한 데이터는 TTL 없이 저장

3. **메모리 관리**
   - 불필요한 데이터 정기 삭제
   - 메모리 사용량 모니터링

4. **연결 풀 설정**
   - Lettuce 연결 풀 사용
   - 최대 연결 수 설정

------------------------------------------------------------
11. Redis 트러블슈팅
------------------------------------------------------------

● 문제: Redis 연결 실패
- 해결: Redis 서버 실행 확인, 호스트/포트 확인

● 문제: 큐에 작업이 쌓이지 않음
- 해결: 큐 키 이름 확인, DB 1 접속 확인

● 문제: 댓글 데이터가 없음
- 해결: 초기 동기화 실행 확인, YouTube API 쿼터 확인

● 문제: 자막 데이터가 없음
- 해결: 자막 추출 설정 확인, yt-dlp 경로 확인

============================================================
